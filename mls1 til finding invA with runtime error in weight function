// Moving Least Square Method //

// Length = Breadth = 3 meter //

// Discritizing the domain and finding the field variables at nodes //

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<cuda.h>
#include "matrixop.h"
#include "inv.cu"
#define F 49
__device__ float A[3][3];
__device__ float invA[3][3];
__device__ float Ax[3][3];
__device__ float Ay[3][3];
__device__ float B[3][F];
__device__ float Bx[3][F];
__device__ float By[3][F];
__device__ void findB(float *w,float *wx,float *wy,float (*p)[F])
{
    int i=threadIdx.x;
    for(int l=0;l<3;l++)
    {
       B[l][i]=w[i]*p[l][i];
       Bx[l][i]=wx[i]*p[l][i];
       By[l][i]=wy[i]*p[l][i];
    }
    if(i==0)
    {
        for(int l=0;l<3;l++)
        {
            for(int n=0;n<F;n++)
            {
                printf("%f\t",B[l][n]);
            }
         printf("\n");
        }
    }
}
__device__ void findA(float *w,float *wx,float *wy,float (*p)[F])
{
    int i=threadIdx.x;
    float AA[F][3][3],AAx[F][3][3],AAy[F][3][3];
    for(int l=0;l<3;l++)
    {
        for(int n=0;n<3;n++)
        {
            AA[i][l][n]=p[l][i]*p[n][i]*w[i];
            AAx[i][l][n]=p[l][i]*p[n][i]*wx[i];
            AAy[i][l][n]=p[l][i]*p[n][i]*wy[i];
            atomicAdd(*(A+l)+n,AA[i][l][n]);
            atomicAdd(*(Ax+l)+n,AAx[i][l][n]);
            atomicAdd(*(Ay+l)+n,AAy[i][l][n]);
        }
    }
}
__global__ void interpfun(float a,float b,int s,int ss,float * Us,float * Usx,float * Usy,float * X,float * Y,float *wx,float *d)
{
    int i=threadIdx.x;
    if(s==1)
    {
      Us[i]=(1+2*X[i]*X[i]+2*Y[i]*Y[i]);
      Usx[i]=(4*X[i]);
      Usy[i]=(4*Y[i]);
    }
    else
    {
      Us[i]=(cos(0.5*M_PI*X[i]))*(cos(0.5*M_PI*Y[i]));
      Usx[i]=0.5*M_PI*(sin(0.5*M_PI*X[i]))*(cos(0.5*M_PI*Y[i]));
      Usy[i]=0.5*M_PI*(cos(0.5*M_PI*X[i]))*(sin(0.5*M_PI*Y[i]));
    }
    
    d[i]=pow((a-X[i])*(a-X[i])+(b-Y[i])*(b-Y[i]),.5);
    d[i]=d[i]/(2.1*.5);
    // Calculating weight functions
    // Quartic Spline
    float w[F],wy[F];
    if(ss==1)
    {
        if(d[i]<1)
        {
            w[i]=1-6*d[i]*d[i]+8*pow(d[i],3)-3*pow(d[i],4);
            wx[i]=(-12*d[i]+24*pow(d[i],2)-12*pow(d[i],3))*(X[i]-a)/d[i];
            wy[i]=(-12*d[i]+24*pow(d[i],2)-12*pow(d[i],3))*(Y[i]-b)/d[i];
        }
        else
        {
            w[i]=0;
            wx[i]=0;
            wy[i]=0;
        }
    }
    // Cubic Spline
    else if(ss==2)
    {
        if(d[i]>1)
        {
            w[i]=0;
            wx[i]=0;
            wy[i]=0;  
        }
        else if(d[i]<=.5)
        {
            w[i]=(2.0/3.0)-4*pow(d[i],2)+4*pow(d[i],3);
            wx[i]=(-8*d[i]+12*pow(d[i],2))*(X[i]-a)/d[i];
            wy[i]=(-8*d[i]+12*pow(d[i],2))*(Y[i]-b)/d[i];
        }
        else
        {
            w[i]=(4.0/3.0)-4*d[i]+4*pow(d[i],2)-(4.0/3.0)*pow(d[i],3);
            wx[i]=(-4+8*d[i]-4*pow(d[i],2))*(X[i]-a)/d[i];
            wy[i]=(-4+8*d[i]-4*pow(d[i],2))*(Y[i]-b)/d[i];
        }
    }
    // Exponential Function
    else if(ss==3)
    {
        float aa=.3;
        if(d[i]<=1)
        {
            w[i]=exp(-pow(d[i]/aa,2));
            wx[i]=-2*w[i]*((X[i]-aa)/aa*aa);
            wy[i]=-2*w[i]*((Y[i]-aa)/aa*aa);   
        }
        else
        {
            w[i]=0;
            wx[i]=0;
            wy[i]=0;
        }
    }
 __syncthreads();
 if(i==0)
    {
        printf("d\n");
        for(int n=0;n<F;n++)
            {
                printf("%f,",d[n]);
            }
        printf("\nw\n");
        for(int n=0;n<F;n++)
            {
                printf("%f,",w[n]);
            }
        printf("\nwx\n");
        for(int n=0;n<F;n++)
            {
                printf("%f,",wx[n]);
            }
        printf("\nwy\n");
        for(int n=0;n<F;n++)
            {
                printf("%f,",wy[n]);
            }
        printf("\n");
    }
 // Computing A and B
    float p[3][F];
    p[0][i]=1;
    p[1][i]=X[i];
    p[2][i]=Y[i];
    findA(w,wx,wy,p);
    findB(w,wx,wy,p);
    float ab[1][3]={1,a,b},g[1][3],gx[1][3],gy[1][3];
    if(i==0)
    {
        inv(A,invA);
    }
}
int main(void)
{
    int k=0,s,ss;
	  float x[49],*X,y[49],*Y,a,b,ua,uax,uby,u,ux,uy,*U,*Ux,*Uy,us[49],*Us,usx[49],*Usx,usy[49],*Usy,wx[F],*Wx,d[F],*D;
	  printf("Give 1 for (1+2*x(k)^2+2*y(k)^2, 2 for cos(.5*M_PI*x).*cos(.5*M_PI*y)\n");
	  scanf("%d",&s);
    printf("Give the coordinates of point to interpolate U and check Kronecker Delta Property a,b \n");
    scanf("%f %f",&a,&b);
    printf("Give 1 for Quartic , 2 for Cubic , 3 for Exponential weight function \n");
    scanf("%d",&ss);
	  for(int i=1;i<8;i++)
   {
       for(int j=1;j<8;j++)
       {
           x[k]=(i-1)*.5;
			     y[k]=(j-1)*.5;
			     k++;
        }
   }
 cudaMalloc(&X,sizeof(x));
 cudaMalloc(&Y,sizeof(y));
 cudaMalloc(&Wx,sizeof(wx));
 cudaMalloc(&D,sizeof(d));
 cudaMemcpy(X,x,sizeof(x),cudaMemcpyHostToDevice);
 cudaMemcpy(Y,y,sizeof(y),cudaMemcpyHostToDevice);
 cudaMalloc(&Us,sizeof(us));
 cudaMalloc(&Usx,sizeof(usx));
 cudaMalloc(&Usy,sizeof(usy));
 interpfun<<<1,49>>>(a,b,s,ss,Us,Usx,Usy,X,Y,Wx,D);
 cudaDeviceSynchronize();
 if(s==1)
 {
     ua=(1+2*a*a+2*b*b);
     uax=(4*a);
     uby=(4*b);
  }
 else
 {
     ua=(cos(0.5*M_PI*a))*(cos(0.5*M_PI*b));
     uax=0.5*M_PI*(sin(0.5*M_PI*a))*(cos(0.5*M_PI*b));
     uby=0.5*M_PI*(cos(0.5*M_PI*a))*(sin(0.5*M_PI*b));
 }
 cudaMemcpy(d,D,sizeof(d),cudaMemcpyDeviceToHost);
 cudaMemcpy(wx,Wx,sizeof(wx),cudaMemcpyDeviceToHost);
// for(int i=0;i<49;i++)
// {
//     printf("%f\t",d[i]);
// }
// printf("\n");
// for(int i=0;i<49;i++)
// {
//     printf("%f\t",wx[i]);
// }
 return 0;
}
